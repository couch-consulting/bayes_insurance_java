/**
Netica Class to Mkae a Decision
 */
class NeticaMakeDecision {

    public static void makeDecision(Net net, List<String> nodes, List<List<String>> classifyCases) {
        try {
            // Would be needed in learn ctp

            // Set decision node TODO if i remove this an actual "network" wtih % will be shown
            //int listLength = nodes.size() - 1;
            //nodesList.remove(net.getNode(nodes.get(listLength)));
            //net.getNode(nodes.get(listLength)).setKind(Node.DECISION_NODE);

            // Problem links do not work because other ctp table stuff
            // Compile net
            net.compile();
            //net.getNode("Tarif").setKind(Node.DECISION_NODE);

            int caseNr = 0;
            for (List<String> classifyCase : classifyCases) {


                // Go through each node for this set and enter findings
                int index = 0;
                int listLength = nodes.size() - 1;
                for (String node : nodes) {
                    // break for last column because it is the evaluation node
                    if (index == listLength) {
                        continue;
                    }
                    // Set state for given input
                    net.getNode(node).finding().enterState(classifyCase.get(index));
                    index++;
                }


                // Results
                String lastNode = nodes.get(listLength);

                float[] utils = net.getNode(lastNode).getExpectedUtils();  // returns expected utilities, given current findings

                System.out.print("For case " + caseNr + ", ");
                System.out.println("the expected utility of " + net.getNode(lastNode).state(0) + " is " + utils[0] +
                        ", of " + net.getNode(lastNode).state(1) + " is " + utils[1] + "\n");


                caseNr++;

                // Reset net
                net.retractFindings();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    //--- 1st type of usage:  To get the expected utilities, given the current findings




            /*
            //--- 2nd type of usage:  To get the optimal decision table

            net.retractFindings();
            umbrella.getExpectedUtils();  // causes Netica to recompute decision tables, given current findings
            // (which in this case are no findings)

            for (int fs = 0; fs < forecast.getNumStates(); ++fs) {
                int[] parStates = new int[1];
                parStates[0] = fs;  // forecast is the parent of umbrella
                int[] decision = umbrella.getStateFuncTable(parStates, null);
                System.out.println("If the forecast is " + forecast.state(fs) +
                        ",\tthe best decision is " + umbrella.state(decision[0]));
            }
            */


}

